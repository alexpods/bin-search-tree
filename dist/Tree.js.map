{"version":3,"sources":["Tree.js"],"names":["BinarySearchTree$696","options$697","this","_root","_min","_max","_length","_cc","module","exports","Iterator$695","require","Object","defineProperties","prototype","root","get","v","rootKey","k","min","minKey","max","maxKey","length","set","key$698","value$699","p","l","r","m","result$700","_search","node$701","_linkNodes","compareKeys","key$702","result$703","has","key$704","key$705","result$706","node$707","_removeNode","clone","nt$708","constructor","forEach","callback$709","min$711","node$712","stack$713","Array","index$714","every","callback$715","min$717","node$718","stack$719","index$720","some","callback$721","min$723","node$724","stack$725","index$726","reduce","callback$727","initialValue$728","result$729","min$731","node$732","stack$733","index$734","reduceRight","callback$735","initialValue$736","result$737","max$739","node$740","stack$741","index$742","Symbol","iterator","values","keys","entries","_traverse","params$743","callback$744","p$745","ro$746","reverse","node$747","from","stps$748","steps","Infinity","dirs$749","up$750","_up","im$751","_im","ff$752","_ff","k1$753","k2$754","cc$755","res$756","toString$757","toString","call","key$758","root$759","res$761","node$760","parent$762","child$763","type$764","res$765","Error","toLowerCase","node$766","parent$767","right$768","left$769","_getMinNode","_getMaxNode","plType$770","root$771","node$772","root$773","node$774"],"mappings":"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","file":"Tree.js","sourceRoot":"/source/","sourcesContent":["module.exports = BinarySearchTree;\n\nvar Iterator = require('./Iterator');\n\nfunction BinarySearchTree(options) {\n    options = options || {};\n\n    if (typeof options === 'function') {\n        options['compare'] = options;\n    }\n\n    this._root   = null;\n    this._min    = null;\n    this._max    = null;\n    this._length = 0;\n    this._cc     = options['compare'];\n}\n\nObject.defineProperties(BinarySearchTree.prototype, {\n\n    root: {\n        get: function() {\n            return this._root.v;\n        }\n    },\n\n    rootKey: {\n        get: function() {\n            return this._root.k;\n        }\n    },\n\n    min: {\n        get: function() {\n            return this._min.v;\n        }\n    },\n\n    minKey: {\n        get: function() {\n            return this._min.k;\n        }\n    },\n\n    max: {\n        get: function() {\n            return this._max.v;\n        }\n    },\n\n    maxKey: {\n        get: function() {\n            return this._max.k;\n        }\n    },\n\n    length: {\n        get: function() {\n            return this._length;\n        }\n    }\n});\n\n/**\n * Insert new value to binary search tree.\n * If key is already exists - than new node is not created, old value is replaced by new one\n *\n * @param key\n * @param value\n *\n * @return {BinarySearchTree} this\n */\nBinarySearchTree.prototype.set = function(key, value) {\n    if (!this._root) {\n        this._root = this._min = this._max = { k: key, v: value, p: null, l: null, r: null, m: null };\n        this._length++;\n        return this;\n    }\n\n    var result = this._search(key);\n\n    if (result[0]) {\n        result[1].v = value;\n        return this;\n    }\n\n    var node = { k: key, v: value, p: null, l: null, r: null, m: null };\n\n    this._linkNodes(result[1], node);\n    this._length++;\n\n    if (this.compareKeys(key, this._min.k) < 0) {\n        this._min = node;\n    }\n    else if (this.compareKeys(key, this._max.k) > 0) {\n        this._max = node;\n    }\n\n    return this;\n};\n\n/**\n * Search for value by specified key.\n * If value for specified key does not exists - throw an error\n *\n * @param   key\n * @returns value\n *\n * @throws {Error} if value for specified key does not exists\n */\nBinarySearchTree.prototype.get = function(key) {\n    var result = this._search(key);\n\n    if (!result[0]) {\n        return;\n    }\n\n    return result[1].v;\n};\n\n/**\n * Checks if value for specified key exists in the binary search tree\n *\n * @param key\n * @returns {Boolean} true if value for specified key exists\n */\nBinarySearchTree.prototype.has = function(key) {\n    return this._search(key)[0];\n};\n\n/**\n * Remove value for specified key.\n * If value for specified key does not exists - throw an error\n *\n * @param   key\n * @returns value Removed value\n *\n * @throws {Error} if value for specified key does not exists\n */\nBinarySearchTree.prototype.delete = function(key) {\n    var result = this._search(key);\n\n    if (!result[0]) {\n        return false;\n    }\n    var node = result[1];\n\n    if (node === this._root) {\n        this._root = this._removeNode(node);\n    }\n    else {\n        this._removeNode(node);\n    }\n    this._length--;\n\n    return true;\n};\n\n/**\n * Creates new tree base on current.\n * Nodes are not cloned.\n *\n * @returns {BinarySearchTree} New binary searched tree based on current\n */\nBinarySearchTree.prototype.clone = function() {\n    var nt = new this.constructor();\n    nt._cc = this._cc;\n\n    return nt;\n};\n\n/**\n * Functional .forEach() method.\n *\n * @param callback Function that is executed once per each element of binary search tree.\n *                 Function has three arguments:\n *                    * value The value of current element being processed in tree.\n *                    * key   The key of current element being processed in tree.\n *                    * three The binary search tree forEach was called upon.\n */\nBinarySearchTree.prototype.forEach = function(callback) {\n    if (this._min === null) {\n        return;\n    }\n\n    TRAVERSE_IN_ORDER_LEFT(this._min, 50, (node) => {\n        callback(node.v, node.k, this);\n    });\n};\n\n/**\n * Functional .every() method.\n *\n * @param callback Function that is executed once per each element of binary search tree.\n *                 Function has three arguments:\n *                    * value The value of current element being processed in tree.\n *                    * key   The key of current element being processed in tree.\n *                    * three The binary search tree forEach was called upon.\n */\nBinarySearchTree.prototype.every = function(callback) {\n    if (this._min === null) {\n        return true;\n    }\n\n    TRAVERSE_IN_ORDER_LEFT(this._min, 50, (node) => {\n        if (!callback(node.v, node.k, this)) {\n            return false;\n        }\n    });\n\n    return true;\n};\n\n\n/**\n * Functional .some() method.\n *\n * @param callback Function that is executed once per each element of binary search tree.\n *                 Function has three arguments:\n *                    * value The value of current element being processed in tree.\n *                    * key   The key of current element being processed in tree.\n *                    * three The binary search tree forEach was called upon.\n */\nBinarySearchTree.prototype.some = function(callback) {\n    if (this._min === null) {\n        return true;\n    }\n\n    TRAVERSE_IN_ORDER_LEFT(this._min, 50, (node) => {\n        if (callback(node.v, node.k, this)) {\n            return true;\n        }\n    });\n\n    return false;\n};\n\n/**\n * Functional .reduce() method.\n *\n * @param callback Function that is executed once per each element of binary search tree.\n *                 Function has three arguments:\n *                    * previousValue The value previously returned in the last invocation of the callback,\n *                                    or initialValue, if supplied\n *                    * currentValue  The value of current element being processed in tree.\n *                    * key           The key of current element being processed in tree.\n *                    * three          The binary search tree forEach was called upon.\n *\n * @param [initialValue] Object to use as the first argument to the first call of the callback.\n *\n * @returns Value return by last callback invocation.\n */\nBinarySearchTree.prototype.reduce = function(callback, initialValue) {\n    if (this._min === null) {\n        return initialValue;\n    }\n    var result = initialValue;\n\n    TRAVERSE_IN_ORDER_LEFT(this._min, 50, (node) => {\n        result = callback(result, node.v, node.k, this);\n    });\n\n    return result;\n};\n\n/**\n * Functional .reduceRight() method.\n *\n * @param callback Function that will be executed once per each element of binary search tree.\n *                 Function has three arguments:\n *                    * previousValue The value previously returned in the last invocation of the callback,\n *                                    or initialValue, if supplied\n *                    * currentValue  The value of current element being processed in tree.\n *                    * key           The key of current element being processed in tree.\n *                    * three          The binary search tree forEach was called upon.\n *\n * @param [initialValue] Object to use as the first argument to the first call of the callback.\n *\n * @returns Value return by last callback invocation.\n */\nBinarySearchTree.prototype.reduceRight = function(callback, initialValue) {\n    if (this._max === null) {\n        return initialValue;\n    }\n    var result = initialValue;\n\n    TRAVERSE_IN_ORDER_RIGHT(this._max, 50, (node) => {\n        result = callback(result, node.v, node.k, this);\n    });\n\n    return result;\n};\n\n\n/**\n * Iterator interface.\n * Support for \"for of\" loop.\n *\n * @yelds Value of node tree.\n */\nBinarySearchTree.prototype[Symbol.iterator] = function() {\n    return this.values();\n};\n\n/**\n * Creates iterator for node values.\n *\n * @returns {BinarySearchTreeIterator} Iterator for node values.\n */\nBinarySearchTree.prototype.values = function() {\n    return new Iterator(this, 'v');\n};\n\n/**\n * Creates iterator for node keys.\n *\n * @return {BinarySearchTreeIterator} Iterator for node keys.\n */\nBinarySearchTree.prototype.keys = function() {\n    return new Iterator(this, 'k');\n};\n\n/**\n * Creates iterator for node key/value pairs.\n *\n * @returns {BinarySearchTreeIterator} Iterator for node key/value paris.\n */\nBinarySearchTree.prototype.entries = function() {\n    return new Iterator(this, 'e');\n};\n\nBinarySearchTree.prototype._traverse = function(params, callback) {\n    var p;\n\n    if (typeof params === 'function') {\n        callback = params;\n        params   = {};\n    }\n\n    var ro   = params.reverse || false; // Reverse Order of traversing\n    var node = params.from    || this._root;\n    var stps = params.steps   || Infinity;\n\n    var dirs = '';\n\n    var up = params._up || false; // traversing is in UP state\n    var im = params._im || false; // traversing is In the Middle state\n    var ff = params._ff || false; // returns full form if callback does not exists\n\n\n    while (stps && node) {\n\n        if (!up) {\n            // pre\n\n            if (ro ? node.r : node.l) {\n                if (ro) {\n                    node = node.r;\n                    if (dirs !== null) {\n                        dirs += 'r';\n                    }\n                }\n                else {\n                    node = node.l;\n                    if (dirs !== null) {\n                        dirs += 'l';\n                    }\n                }\n                up   = false;\n                im   = false;\n                continue;\n            }\n        }\n\n        if (!up || im) {\n            if (node !== params.from) {\n                --stps;\n                if (callback) {\n                    if ('break' === callback(node, dirs)) {\n                        return;\n                    }\n                    dirs = '';\n                }\n                else if (0 === stps) {\n                    return ff ? [node, dirs, up, im] : null;\n                }\n            }\n\n            if (ro ? node.l : node.r) {\n                if (ro) {\n                    node = node.l;\n                    dirs += 'l';\n                }\n                else {\n                    node = node.r;\n                    dirs += 'r';\n                }\n                up   = false;\n                im   = false;\n                continue;\n            }\n        }\n\n        // post\n\n        up   = true;\n        p    = node.p;\n        im   = p && (node === (ro ? p.r : p.l ));\n        if (p) {\n            dirs += node === p.r  ? 'R' : 'L';\n        }\n        node = p;\n    }\n\n    if (!callback) {\n        return null;\n    }\n};\n\n/**\n * Comparison of two node keys\n *\n * @param k1\n * @param k2 Second node\n * @returns {Number} negative - if node1 \"less then\" node 2,\n *                   positive - if node1 \"greater then\" node2\n *                   0 - otherwise\n */\nBinarySearchTree.prototype.compareKeys = function(k1, k2) {\n    var cc  = this._cc;\n    var res = cc && cc(k1, k2);\n    var toString = Object.prototype.toString;\n\n    if (typeof res !== 'undefined') {\n        return toString.call(res) === '[object Number]' ? res : (res ? -1 : 1);\n    }\n\n    if (k1 === k2) {\n        return 0;\n    }\n    return k1 > k2 ? 1 : -1;\n};\n\n/**\n * Search node in subtree specified by its root.\n * If root does not specified than current tree root is taken\n *\n * @param key   Key of searching node\n * @param root  Subtree root. By default current tree root is taken\n * @returns {Array} Array [searchResult, node] where\n *                      * searchResult - true if node was found\n *                      * node         - searched node if it was found, otherwise last checked node\n *\n * @protected\n */\nBinarySearchTree.prototype._search = function(key, root) {\n    var node = root || this._root, res;\n\n    if (!node) {\n        return [false, node];\n    }\n\n    while (res = this.compareKeys(key, node.k)) {\n        if (res < 0) {\n            if (!node.l) {\n                return [false, node];\n            }\n            node = node.l;\n        }\n        else {\n            if (!node.r) {\n                return [false, node];\n            }\n            node = node.r;\n        }\n    }\n\n    return [true, node];\n};\n\n/**\n * Links parent and child nodes\n *\n * @param parent\n * @param child\n * @param [type]\n *\n * @protected\n */\nBinarySearchTree.prototype._linkNodes = function(parent, child, type) {\n    child.p  = parent;\n\n    var res = this.compareKeys(child.k, parent.k);\n\n    if (res === 0) {\n        throw new Error('Could not link parent and child nodes with equal keys!');\n    }\n\n    if (typeof type !== 'undefined') {\n        switch (type.toLowerCase()) {\n            case 'l':\n            case 'left':  parent.l = child; break;\n            case 'r':\n            case 'right': parent.r = child; break;\n            default:\n                throw new Error('Incorrect link nodes type!');\n        }\n    }\n    else {\n        res < 0 ? parent.l = child : parent.r = child;\n    }\n};\n\n/**\n * Remove specified node\n *\n * @param node\n *\n * @protected\n */\nBinarySearchTree.prototype._removeNode = function(node) {\n    var parent = node.p;\n    var right  = node.l;\n    var left   = node.r;\n\n    if (node === this._min) {\n        this._min = node.r ? this._getMinNode(node.r) : node.p;\n    }\n    if (node === this._max) {\n        this._max = node.l ? this._getMaxNode(node.l) : node.p;\n    }\n\n    var plType = parent && (parent.l === node ? 'left' : 'right'); // parent link type\n\n    if (!left && !right) {\n        if (parent) {\n            plType === 'left' ? parent.l = null : parent.r = null;\n            node.p = null;\n        }\n        return parent;\n    }\n\n\n    if (!left) {\n        if (parent) {\n            this._linkNodes(parent, right, plType);\n            node.p = null;\n        }\n        else {\n            right.p = null;\n        }\n        node.r = null;\n\n        return parent || right;\n    }\n\n    if (!right) {\n        if (parent) {\n            this._linkNodes(parent, left, plType);\n            node.p = null;\n        }\n        else {\n            left.p = null;\n        }\n        node.l = null;\n\n        return parent || left;\n    }\n\n    this._linkNodes(this._getMaxNode(left), right, 'right');\n\n    if (parent) {\n        this._linkNodes(parent, left, plType);\n        node.p = null;\n    }\n    else {\n        left.p = null;\n    }\n\n    node.l = null;\n    node.r = null;\n\n    return parent || left;\n};\n\n/**\n * Gets min key node for specified subtree by its root\n * If root does not specified than current tree root is taken\n *\n * @param root Subtree root node\n * @returns Node with minimum key\n *\n * @protected\n */\nBinarySearchTree.prototype._getMinNode = function(root) {\n    var node = root || this._root;\n\n    while (node.l) {\n        node = node.l;\n    }\n\n    return node;\n};\n\n/**\n * Gets max key node for specified subtree by its root\n * If root does not specified than current tree root is taken\n *\n * @param   root Subtree root node\n * @returns Node with maximum key\n *\n * @protected\n */\nBinarySearchTree.prototype._getMaxNode = function(root) {\n    var node = root || this._root;\n\n    while (node.r) {\n        node = node.r;\n    }\n\n    return node;\n};"]}